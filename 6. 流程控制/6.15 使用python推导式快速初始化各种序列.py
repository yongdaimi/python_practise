# 使用推导式可以快速初始化各种序列(包括：列表、元组、字典和集合), 推导式可细分为：
# 列表推导式、元组推导式、字典推导式、集合推导式

#==================================================
#                   列表推导式
#==================================================

# 语法：
# [表达式 for 迭代变量 in 可迭代对象 [if条件表达式]]

# 例一： 将range()中的元素初始化为它的平方值：
a = [x * x for x in range(10)]
print(a) # 输出：[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]


# 例二：将range()中偶数初始化为它的平方值：
a = [x * x for x in range(10) if x % 2 == 0]
print(a) # 输出：[0, 4, 16, 36, 64]

# 例三：找到0-100里面所有的偶数值：
a = [x for x in range(101) if x % 2 == 0]
print(a)
''''
输出：
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 
48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]
'''

# 例四：使用多个循环生成数据
a = [(x, y) for x in range(5) for y in range(4)]
print(a)
'''
输出：
[(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3), (4, 0), (4, 1), (4, 2), (4, 3)]
'''
print("------------------------------------------------")

# 例五：将两个列表中的数值按“能否整除”的关系配对在一起
a = [1, 3, 4, 5, 7, 9, 2]
b = [20, 45, 68, 29, 22, 10, 20, 32, 11]
ret = [(x, y) for x in a for y in b if y % x == 0]
print(ret)
print("共%d组" %len(ret))
'''
[(1, 20), (1, 45), (1, 68), (1, 29), (1, 22), (1, 10), (1, 20), (1, 32), (1, 11), (3, 45), (4, 20), (4, 68), (4, 20), (4, 32), (5, 20), (5, 45), (5, 10),
 (5, 20), (9, 45), (2, 20), (2, 68), (2, 22), (2, 10), (2, 20), (2, 32)]
共25组
'''


#==================================================
#                   元组推导式
#==================================================

# 语法：(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )

# 例一：生成一个1-9数字的元组
a = (x for x in range(1, 10))
print(a)                    # 输出：<generator object <genexpr> at 0x0000027A61A41FC0>, 直接输出结果会打印表达式
# print(tuple(a))             # 输出：(1, 2, 3, 4, 5, 6, 7, 8, 9)

print(a.__next__())         # 输出：1
print(a.__next__())         # 输出：2
print(a.__next__())         # 输出：3
a = tuple(a)
print(a)                    # 输出：(4, 5, 6, 7, 8, 9)

'''
注意：
无论是使用 for 循环遍历生成器对象，还是使用 __next__() 方法遍历生成器对象，遍历后原生成器中的对象将不复存在，
所以只会输出：(4, 5, 6, 7, 8, 9)
'''


#==================================================
#                   字典推导式
#==================================================

# 语法：{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]}

# 例一：以列表中的各字符串为键，字符串的长度为值，组成键值对
a = ["http://www.baidu.com", "http://www.qq.com", "http://www.microsoft.com"]
b = {k:len(k) for k in a}
print(b) # 输出：{'http://www.baidu.com': 20, 'http://www.qq.com': 17, 'http://www.microsoft.com': 24}

# 例二: 交换现有字典中的key和value ? 错误的写法，但是不知道哪里错了
#c = {v:k for k in b.keys() for v in b.values()}
# print(c) # 输出：{20: 'http://www.microsoft.com', 17: 'http://www.microsoft.com', 24: 'http://www.microsoft.com'}

# 例二: 简化写法
c = {v:k for k, v in b.items()}
print(c)


#==================================================
#                   集合推导式
#==================================================


# 语法：{ 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] }

# 如何区分集合表达式与字典表达式
# 集合表达式与字典表达式很像，都是用大括号进行包裹，如果表达式是键值对，则说明是字典表达式；否则则为集合表达式

# 例一：生成range中的元素的乘方
list1 = [1, 2, 3, 4, 5, 6, 7, 8]
values = {x**2 for x in list1}
print(values) # 输出：{64, 1, 4, 36, 9, 16, 49, 25}， set集合中的元素是无序的


# 例二: 生成range中的偶数元素的乘方
values = {x**2 for x in list1 if x % 2 == 0}
print(values) # 输出：{16, 64, 4, 36}


# 例三：使用字典中的键来生成集合
dictdemo = {'1':1, '2':2, '3':3}
values = {x for x in dictdemo.keys()}
print(values) # 输出 {'1', '3', '2'}